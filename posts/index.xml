<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on miss you</title>
    <link>https://Yfei1104.github.io/posts/</link>
    <description>Recent content in Posts on miss you</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Sep 2020 10:49:51 +0800</lastBuildDate>
    
	<atom:link href="https://Yfei1104.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>golang-worker-pool</title>
      <link>https://Yfei1104.github.io/2020/go-worker-pool/</link>
      <pubDate>Wed, 09 Sep 2020 10:49:51 +0800</pubDate>
      
      <guid>https://Yfei1104.github.io/2020/go-worker-pool/</guid>
      <description>/待完成</description>
    </item>
    
    <item>
      <title>leetcode-二分查找</title>
      <link>https://Yfei1104.github.io/2020/leetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sat, 08 Aug 2020 21:15:11 +0800</pubDate>
      
      <guid>https://Yfei1104.github.io/2020/leetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
      <description>leetcode 69. x的平方根  题目描述：实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
 一个数的开方sqrt一定在0~x之间，满足sqrt == x / sqrt。所以利用二分查找。
class Solution { public: int mySqrt(int x) { int l = 0, r = x; while (l &amp;lt; r) { int mid = l + r + 1ll &amp;gt;&amp;gt; 1; if (mid &amp;lt;= x / mid)	l = mid; else	r = mid - 1; } return r; } }; leetcode 35.</description>
    </item>
    
    <item>
      <title>golang-cache2go-2</title>
      <link>https://Yfei1104.github.io/2020/go-library-cache2go-2/</link>
      <pubDate>Sat, 08 Aug 2020 17:22:57 +0800</pubDate>
      
      <guid>https://Yfei1104.github.io/2020/go-library-cache2go-2/</guid>
      <description>上次我们介绍了cache2go缓存库的两种类型和其中的一些方法的实现，今天我们接着继续详细介绍cachetable类型提供的一些方法的实现。
缓存表提供了缓存常见的方法：
 增：Add，NotFoundAdd 删：Delete 查：Value 过期检查：expirationCheck 缓存刷新：Flush 缓存遍历：Foreach 回调函数设置：SetAboutToDeleteItemCallback，SetAddedItemCallback，SetDataLoader 访问最多的前几个缓存项：MostAccessed &amp;hellip;  添加缓存   首先通过NewCacheItem(key, lifeSpan, value)来完成CacheItem的初始化 接下里需要通过调用自身的addInternal(cacheItem)将cacheItem添加到cacheTable中，并且执行添加item的回调函数 当cleanupInterval等于0或者lifespan&amp;lt;cleanupInterval时开始检查是否有过期缓存 addInternal()方法要在加锁之后才能调用，并且在执行callback之前不能解除锁  func (table *CacheTable) addInternal(item *CacheItem) { // 要在加锁之后才能调用该方法，并且在执行callback之前不能解除锁  ... table.items[item.key] = item expDur := table.cleanupInterval addedItem := table.addedItem table.Unlock() // 添加item的回调函数 	if addedItem != nil { for _, callback := range addedItem { callback(item) } } // lifespan小于清除间隔时就要执行过期检查，重设cleanupInterval 	if item.lifeSpan &amp;gt; 0 &amp;amp;&amp;amp; (expDur == 0 || item.</description>
    </item>
    
    <item>
      <title>golang-cache2go-1</title>
      <link>https://Yfei1104.github.io/2020/go-library-caches2go-1/</link>
      <pubDate>Sat, 08 Aug 2020 10:26:52 +0800</pubDate>
      
      <guid>https://Yfei1104.github.io/2020/go-library-caches2go-1/</guid>
      <description>今天学习比较容易上手的开源缓存库cache2go。
cache2go  此开源库的作者是这样介绍cache2go的
Concurrency-safe golang caching library with expiration capabilities. cache2go是一个保证并发安全的并带有过期控制功能的缓存库 它是一个用go实现并发安全的缓存库，实现了以下的特征：
  并发安全
  可设置每条缓存的超时时间
  内置了缓存访问计数
  自调节的缓存过期检查
  缓存的回调函数
  &amp;hellip;
  库的核心代码就三个文件，主要的技术包括锁机制、goroutine、map操作等等，很适合初学者学习。
源码解析  cache2go中主要涉及到两个类型cacheitem、cachetable。
 一个cacheitem代表了一条缓存 一个cachetable代表了一个缓存表，由一条条缓存组成  cacheitem  type CacheItem struct { sync.RWMutex // The item&amp;#39;s key. 	key interface{} // The item&amp;#39;s data. 	data interface{} // How long will the item live in the cache when not being accessed/kept alive.</description>
    </item>
    
    <item>
      <title>leetcode-双指针-2</title>
      <link>https://Yfei1104.github.io/2020/leetcode-%E5%8F%8C%E6%8C%87%E9%92%88-2/</link>
      <pubDate>Fri, 07 Aug 2020 20:22:30 +0800</pubDate>
      
      <guid>https://Yfei1104.github.io/2020/leetcode-%E5%8F%8C%E6%8C%87%E9%92%88-2/</guid>
      <description>leetcode 88. 合并两个有序数组  题目描述：给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
  从后往前遍历两个数组，当能同时遍历到数的时候就比较两个数的大小。添加位置从num1数组的num1.size() + nums2.size() - 1开始往前。 当无法同时获取两个数时，就看看num2数组还有没有数，有的话就添加到nums1中。  class Solution { public: void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) { int i = m - 1, j = n - 1, k = m + n - 1; while (i &amp;gt;= 0 &amp;amp;&amp;amp; j &amp;gt;= 0) if (nums1[i] &amp;gt;= nums2[j])	nums1[k--] = nums1[i--]; else	nums1[k--] = nums2[j--]; while (j &amp;gt;= 0)	nums1[k--] = nums2[j--]; } }; 时间复杂度：O(m + n)</description>
    </item>
    
    <item>
      <title>golang-scheduler</title>
      <link>https://Yfei1104.github.io/2020/go-scheduler/</link>
      <pubDate>Tue, 04 Aug 2020 14:16:35 +0800</pubDate>
      
      <guid>https://Yfei1104.github.io/2020/go-scheduler/</guid>
      <description>goroutine是go语言原生支持并发的表现形式。编写的go代码无一例外都是在goroutine中运行的。你可以启动许多甚至成千上万个的goroutine，go的runtime就是负责对goroutine进行调度，决定哪个goroutine获取资源，哪个goroutine让出资源等等。适当了解一下goroutine的调度模型和原理，对于编写出更好的go代码是大有裨益的。
当我们提起go语言调度器，就绕不开操作系统、进程、线程这些概念。线程是操作系统调度时的最基本单元，，在不同的操作系统上进程和线程有不同的实现，比如linux系统调度器就不区分进程和线程的调度，但是绝大部分的实现中线程都是属于进程的。
未完待续。。。
https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/
https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/
https://www.cnblogs.com/mokafamily/p/9975980.html
https://learnku.com/articles/45302
https://www.jianshu.com/p/d5c48704c2f9</description>
    </item>
    
    <item>
      <title>leetcode-双指针-1</title>
      <link>https://Yfei1104.github.io/2020/leetcode-%E5%8F%8C%E6%8C%87%E9%92%88-1/</link>
      <pubDate>Mon, 03 Aug 2020 15:59:15 +0800</pubDate>
      
      <guid>https://Yfei1104.github.io/2020/leetcode-%E5%8F%8C%E6%8C%87%E9%92%88-1/</guid>
      <description>leetcode 167. 两数之和 II - 输入有序数组  题目描述：给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。
函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。
 方法一：二分查找 在数组中找到两个数之和等于目标值，可以先固定一个数，然后利用有序数组的性质，二分查找第二个数。为了避免重复，第二个数只能从第一个数右侧找。
遍历数组时间复杂度O(N)，二分查找O(lgN)，所以总的时间复杂度O(NlgN)。空间复杂度O(1)。
class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; num, int target) { for (int i = 0; i &amp;lt; num.size(); i ++) { int l = i + 1, r = num.size() - 1; while (l &amp;lt; r) { int mid = (l + r) &amp;gt;&amp;gt; 1; if (num[mid] &amp;gt;= target - num[i])	r = mid; else	l = mid + 1; } if (num[l] + num[r] == target)	return {i + 1, l + 1}; } return {-1, -1}; } }; 方法二：双指针 使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</description>
    </item>
    
    <item>
      <title>golang-获取文件的大小</title>
      <link>https://Yfei1104.github.io/2020/go-filesize/</link>
      <pubDate>Sat, 01 Aug 2020 21:16:53 +0800</pubDate>
      
      <guid>https://Yfei1104.github.io/2020/go-filesize/</guid>
      <description>在go语言中，我们有很多方法获取一个文件的大小。
Read字节方式  第一种，当然是最常见的read()方法，也就是打开文件，把文件读一遍
func main() { file, err := os.open(&amp;#34;filename&amp;#34;) if err == nil { sum := 0 buf := make([]byte, 1024) for { n, err := file.read(buf) sum += n if err == io.EOF { break } } fmt.Println(&amp;#34;file size is &amp;#34;, sum) } } 这种方式需要打开文件，通过for循环反复的读取文件里面的内容，然后去计算文件的大小。效率低，代码量大。
ioutil方式  由于上面的代码量比较大，所以我们可能立刻会想到使用ioutul包的ReadFile()方法来替代，直接获取文件的内容，然后计算出文件的大小。
func main() { contents, err := ioutil.ReadFile(&amp;#34;filename&amp;#34;) if err == nil { fmt.Println(&amp;#34;file size is &amp;#34;, len(contents)) } } 虽然ioutil通过三行代码就可以搞定，但是这同时也存在着效率低的问题，尤其是当我们读取大型文件的时候。</description>
    </item>
    
    <item>
      <title>写博客的开始</title>
      <link>https://Yfei1104.github.io/2020/firstblog/</link>
      <pubDate>Sat, 01 Aug 2020 20:44:05 +0800</pubDate>
      
      <guid>https://Yfei1104.github.io/2020/firstblog/</guid>
      <description>从2020.8.1开始写博客，分享自己的所见所闻所感。</description>
    </item>
    
  </channel>
</rss>